"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lru-cache";
exports.ids = ["vendor-chunks/lru-cache"];
exports.modules = {

/***/ "(rsc)/./node_modules/lru-cache/dist/cjs/index-cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/lru-cache/dist/cjs/index-cjs.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nconst index_js_1 = __importDefault(__webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/lru-cache/dist/cjs/index.js\"));\nmodule.exports = Object.assign(index_js_1.default, {\n    default: index_js_1.default,\n    LRUCache: index_js_1.default\n}); //# sourceMappingURL=index-cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2Rpc3QvY2pzL2luZGV4LWNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBLE1BQU1FLGFBQWFILGdCQUFnQkksbUJBQU9BLENBQUMsb0VBQVk7QUFDdkRDLE9BQU9DLE9BQU8sR0FBR0MsT0FBT0MsTUFBTSxDQUFDTCxXQUFXTSxPQUFPLEVBQUU7SUFBRUEsU0FBU04sV0FBV00sT0FBTztJQUFFQyxVQUFVUCxXQUFXTSxPQUFPO0FBQUMsSUFDL0cscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZG1zLy4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9kaXN0L2Nqcy9pbmRleC1janMuanM/ZDlmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGluZGV4X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaW5kZXguanNcIikpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKGluZGV4X2pzXzEuZGVmYXVsdCwgeyBkZWZhdWx0OiBpbmRleF9qc18xLmRlZmF1bHQsIExSVUNhY2hlOiBpbmRleF9qc18xLmRlZmF1bHQgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1janMuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJpbmRleF9qc18xIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZhdWx0IiwiTFJVQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/lru-cache/dist/cjs/index-cjs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/lru-cache/dist/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/lru-cache/dist/cjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @module LRUCache\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LRUCache = void 0;\nconst perf = typeof performance === \"object\" && performance && typeof performance.now === \"function\" ? performance : Date;\nconst warned = new Set();\nconst emitWarning = (msg, type, code, fn)=>{\n    typeof process === \"object\" && process && typeof process.emitWarning === \"function\" ? process.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nconst shouldWarn = (code)=>!warned.has(code);\nconst TYPE = Symbol(\"type\");\nconst isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */ // This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */ class ZeroArray extends Array {\n    constructor(size){\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls) return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls){\n        /* c8 ignore start */ if (!Stack.#constructing) {\n            throw new TypeError(\"instantiate Stack using Stack.create(n)\");\n        }\n        /* c8 ignore stop */ this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */ class LRUCache {\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */ static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head () {\n                return c.#head;\n            },\n            get tail () {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index)=>c.#moveToTail(index),\n            indexes: (options)=>c.#indexes(options),\n            rindexes: (options)=>c.#rindexes(options),\n            isStale: (index)=>c.#isStale(index)\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */ get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */ get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */ get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */ get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */ get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */ get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */ get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options){\n        // conditionally set private methods related to TTL\n        this.#updateItemAge = ()=>{};\n        this.#statusTTL = ()=>{};\n        this.#setItemTTL = ()=>{};\n        /* c8 ignore stop */ this.#isStale = ()=>false;\n        this.#removeItemSize = (_i)=>{};\n        this.#addItemSize = (_i, _s, _st)=>{};\n        this.#requireSize = (_k, _v, size, sizeCalculation)=>{\n            if (size || sizeCalculation) {\n                throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n            }\n            return 0;\n        };\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError(\"max option must be a nonnegative integer\");\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error(\"invalid max value: \" + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n            }\n            if (typeof this.sizeCalculation !== \"function\") {\n                throw new TypeError(\"sizeCalculation set to non-function\");\n            }\n        }\n        if (fetchMethod !== undefined && typeof fetchMethod !== \"function\") {\n            throw new TypeError(\"fetchMethod must be a function if specified\");\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === \"function\") {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === \"function\") {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        } else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError(\"maxSize must be a positive integer if specified\");\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError(\"ttl must be a positive integer if specified\");\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = \"LRU_CACHE_UNBOUNDED\";\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = \"TTL caching without ttlAutopurge, max, or maxSize can \" + \"result in unbounded memory consumption.\";\n                emitWarning(msg, \"UnboundedCacheWarning\", code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the remaining TTL time for a given entry key\n     */ getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now())=>{\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(()=>{\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n        };\n        this.#updateItemAge = (index)=>{\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index)=>{\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                status.remainingTTL = status.now + ttl - start;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = ()=>{\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n            return n;\n        };\n        this.getRemainingTTL = (key)=>{\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            return ttls[index] === 0 || starts[index] === 0 ? Infinity : starts[index] + ttls[index] - (cachedNow || getNow());\n        };\n        this.#isStale = (index)=>{\n            return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];\n        };\n    }\n    #updateItemAge;\n    #statusTTL;\n    #setItemTTL;\n    #isStale;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = (index)=>{\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation)=>{\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== \"function\") {\n                        throw new TypeError(\"sizeCalculation must be a function\");\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n                    }\n                } else {\n                    throw new TypeError(\"invalid size value (must be positive integer). \" + \"When maxSize or maxEntrySize is used, sizeCalculation \" + \"or size must be set.\");\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status)=>{\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while(this.#calculatedSize > maxSize){\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize;\n    #addItemSize;\n    #requireSize;\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#tail; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                } else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#head; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                } else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */ *entries() {\n        for (const i of this.#indexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */ *rentries() {\n        for (const i of this.#rindexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */ *keys() {\n        for (const i of this.#indexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */ *rkeys() {\n        for (const i of this.#rindexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */ *values() {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */ *rvalues() {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to Array.find().  fn is called as fn(value, key, cache).\n     */ find(fn, getOptions = {}) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from\n     * most recently used to least recently used.  fn is called as\n     * fn(value, key, cache).  Does not update age or recenty of use.\n     * Does not iterate over stale values.\n     */ forEach(fn, thisp = this) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */ rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */ purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({\n            allowStale: true\n        })){\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to cache.load()\n     */ dump() {\n        const arr = [];\n        for (const i of this.#indexes({\n            allowStale: true\n        })){\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined || key === undefined) continue;\n            const entry = {\n                value\n            };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([\n                key,\n                entry\n            ]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     * Note that the shape of the resulting cache may be different if the\n     * same options are not used in both caches.\n     */ load(arr) {\n        this.clear();\n        for (const [key, entry] of arr){\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     */ set(k, v, setOptions = {}) {\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = \"miss\";\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status) status.set = \"add\";\n            noUpdateTTL = false;\n        } else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error(\"replaced\"));\n                } else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, \"set\");\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([\n                            oldVal,\n                            k,\n                            \"set\"\n                        ]);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = \"replace\";\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n                    if (oldValue !== undefined) status.oldValue = oldValue;\n                }\n            } else if (status) {\n                status.set = \"update\";\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status) this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */ pop() {\n        try {\n            while(this.#size){\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                } else if (val !== undefined) {\n                    return val;\n                }\n            }\n        } finally{\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while(task = dt?.shift()){\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error(\"evicted\"));\n        } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, \"evict\");\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([\n                    v,\n                    k,\n                    \"evict\"\n                ]);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        } else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */ has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = \"hit\";\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            } else if (status) {\n                status.has = \"stale\";\n                this.#statusTTL(status, index);\n            }\n        } else if (status) {\n            status.has = \"miss\";\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */ peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined && (allowStale || !this.#isStale(index))) {\n            const v = this.#valList[index];\n            // either stale and allowed, or forcing a refresh of non-stale value\n            return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        }\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AbortController();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener(\"abort\", ()=>ac.abort(signal.reason), {\n            signal: ac.signal\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context\n        };\n        const cb = (v, updateCache = false)=>{\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort) options.status.fetchAbortIgnored = true;\n                } else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    } else {\n                        this.delete(k);\n                    }\n                } else {\n                    if (options.status) options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er)=>{\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er)=>{\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                } else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            } else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej)=>{\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then((v)=>res(v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener(\"abort\", ()=>{\n                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n                    res();\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = (v)=>cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status) options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, {\n                ...fetchOpts.options,\n                status: undefined\n            });\n            index = this.#keyMap.get(k);\n        } else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod) return false;\n        const b = p;\n        return !!b && b instanceof Promise && b.hasOwnProperty(\"__staleWhileFetching\") && b.__abortController instanceof AbortController;\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status) status.fetch = \"get\";\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status) status.fetch = \"miss\";\n            const p = this.#backgroundFetch(k, index, options, context);\n            return p.__returned = p;\n        } else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = \"inflight\";\n                    if (stale) status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : v.__returned = v;\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status) status.fetch = \"hit\";\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status) this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? \"stale\" : \"refresh\";\n                if (staleVal && isStale) status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : p.__returned = p;\n        }\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */ get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status) this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status) status.get = \"stale\";\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale) status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                } else {\n                    if (status && allowStale && value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            } else {\n                if (status) status.get = \"hit\";\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        } else if (status) {\n            status.get = \"miss\";\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            } else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     * Returns true if the key was deleted, false otherwise.\n     */ delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                } else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error(\"deleted\"));\n                    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, \"delete\");\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([\n                                v,\n                                k,\n                                \"delete\"\n                            ]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    } else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    } else {\n                        this.#next[this.#prev[index]] = this.#next[index];\n                        this.#prev[this.#next[index]] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */ clear() {\n        for (const index of this.#rindexes({\n            allowStale: true\n        })){\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error(\"deleted\"));\n            } else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, \"delete\");\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([\n                        v,\n                        k,\n                        \"delete\"\n                    ]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache;\nexports[\"default\"] = LRUCache; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7O0NBRUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUcsT0FBTyxPQUFPQyxnQkFBZ0IsWUFDaENBLGVBQ0EsT0FBT0EsWUFBWUMsR0FBRyxLQUFLLGFBQ3pCRCxjQUNBRTtBQUNOLE1BQU1DLFNBQVMsSUFBSUM7QUFDbkIsTUFBTUMsY0FBYyxDQUFDQyxLQUFLQyxNQUFNQyxNQUFNQztJQUNsQyxPQUFPQyxZQUFZLFlBQ2ZBLFdBQ0EsT0FBT0EsUUFBUUwsV0FBVyxLQUFLLGFBQzdCSyxRQUFRTCxXQUFXLENBQUNDLEtBQUtDLE1BQU1DLE1BQU1DLE1BQ3JDRSxRQUFRQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUVKLEtBQUssRUFBRSxFQUFFRCxLQUFLLEVBQUUsRUFBRUQsSUFBSSxDQUFDO0FBQ25EO0FBQ0EsTUFBTU8sYUFBYSxDQUFDTCxPQUFTLENBQUNMLE9BQU9XLEdBQUcsQ0FBQ047QUFDekMsTUFBTU8sT0FBT0MsT0FBTztBQUNwQixNQUFNQyxXQUFXLENBQUNDLElBQU1BLEtBQUtBLE1BQU1DLEtBQUtDLEtBQUssQ0FBQ0YsTUFBTUEsSUFBSSxLQUFLRyxTQUFTSDtBQUN0RSxtQkFBbUIsR0FDbkIsd0NBQXdDO0FBQ3hDLHNFQUFzRTtBQUN0RSx1RUFBdUU7QUFDdkUsdUVBQXVFO0FBQ3ZFLHdFQUF3RTtBQUN4RSx1REFBdUQ7QUFDdkQsMkJBQTJCO0FBQzNCLHdEQUF3RDtBQUN4RCxNQUFNSSxlQUFlLENBQUNDLE1BQVEsQ0FBQ04sU0FBU00sT0FDbEMsT0FDQUEsT0FBT0osS0FBS0ssR0FBRyxDQUFDLEdBQUcsS0FDZkMsYUFDQUYsT0FBT0osS0FBS0ssR0FBRyxDQUFDLEdBQUcsTUFDZkUsY0FDQUgsT0FBT0osS0FBS0ssR0FBRyxD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UUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDeUIsS0FBSyxFQUFFO1lBQ2IsSUFBSSxDQUFDLENBQUNBLEtBQUssQ0FBQ3pCLElBQUksQ0FBQztRQUNyQjtRQUNBLElBQUksQ0FBQyxDQUFDcUIsSUFBSSxHQUFHO1FBQ2IsSUFBSSxDQUFDLENBQUNDLElBQUksR0FBRztRQUNiLElBQUksQ0FBQyxDQUFDQyxJQUFJLENBQUNmLE1BQU0sR0FBRztRQUNwQixJQUFJLENBQUMsQ0FBQ08sY0FBYyxHQUFHO1FBQ3ZCLElBQUksQ0FBQyxDQUFDaEIsSUFBSSxHQUFHO1FBQ2IsSUFBSSxJQUFJLENBQUMsQ0FBQytCLGVBQWUsSUFBSSxJQUFJLENBQUMsQ0FBQ04sUUFBUSxFQUFFO1lBQ3pDLE1BQU1zRyxLQUFLLElBQUksQ0FBQyxDQUFDdEcsUUFBUTtZQUN6QixJQUFJdUc7WUFDSixNQUFRQSxPQUFPRCxJQUFJRSxRQUFVO2dCQUN6QixJQUFJLENBQUMsQ0FBQ25ILFlBQVksTUFBTWtIO1lBQzVCO1FBQ0o7SUFDSjtBQUNKO0FBQ0FySyxnQkFBZ0IsR0FBR0U7QUFDbkJGLGtCQUFlLEdBQUdFLFVBQ2xCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Rtcy8uL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvZGlzdC9janMvaW5kZXguanM/NzkzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQG1vZHVsZSBMUlVDYWNoZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxSVUNhY2hlID0gdm9pZCAwO1xuY29uc3QgcGVyZiA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgICBwZXJmb3JtYW5jZSAmJlxuICAgIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbidcbiAgICA/IHBlcmZvcm1hbmNlXG4gICAgOiBEYXRlO1xuY29uc3Qgd2FybmVkID0gbmV3IFNldCgpO1xuY29uc3QgZW1pdFdhcm5pbmcgPSAobXNnLCB0eXBlLCBjb2RlLCBmbikgPT4ge1xuICAgIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBwcm9jZXNzICYmXG4gICAgICAgIHR5cGVvZiBwcm9jZXNzLmVtaXRXYXJuaW5nID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcHJvY2Vzcy5lbWl0V2FybmluZyhtc2csIHR5cGUsIGNvZGUsIGZuKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoYFske2NvZGV9XSAke3R5cGV9OiAke21zZ31gKTtcbn07XG5jb25zdCBzaG91bGRXYXJuID0gKGNvZGUpID0+ICF3YXJuZWQuaGFzKGNvZGUpO1xuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuY29uc3QgaXNQb3NJbnQgPSAobikgPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vLyBUaGlzIGlzIGEgbGl0dGxlIGJpdCByaWRpY3Vsb3VzLCB0YmguXG4vLyBUaGUgbWF4aW11bSBhcnJheSBsZW5ndGggaXMgMl4zMi0xIG9yIHRoZXJlYWJvdXRzIG9uIG1vc3QgSlMgaW1wbHMuXG4vLyBBbmQgd2VsbCBiZWZvcmUgdGhhdCBwb2ludCwgeW91J3JlIGNhY2hpbmcgdGhlIGVudGlyZSB3b3JsZCwgSSBtZWFuLFxuLy8gdGhhdCdzIH4zMkdCIG9mIGp1c3QgaW50ZWdlcnMgZm9yIHRoZSBuZXh0L3ByZXYgbGlua3MsIHBsdXMgd2hhdGV2ZXJcbi8vIGVsc2UgdG8gaG9sZCB0aGF0IG1hbnkga2V5cyBhbmQgdmFsdWVzLiAgSnVzdCBmaWxsaW5nIHRoZSBtZW1vcnkgd2l0aFxuLy8gemVyb2VzIGF0IGluaXQgdGltZSBpcyBicnV0YWwgd2hlbiB5b3UgZ2V0IHRoYXQgYmlnLlxuLy8gQnV0IHdoeSBub3QgYmUgY29tcGxldGU/XG4vLyBNYXliZSBpbiB0aGUgZnV0dXJlLCB0aGVzZSBsaW1pdHMgd2lsbCBoYXZlIGV4cGFuZGVkLlxuY29uc3QgZ2V0VWludEFycmF5ID0gKG1heCkgPT4gIWlzUG9zSW50KG1heClcbiAgICA/IG51bGxcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCA4KVxuICAgICAgICA/IFVpbnQ4QXJyYXlcbiAgICAgICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpXG4gICAgICAgICAgICA/IFVpbnQxNkFycmF5XG4gICAgICAgICAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAzMilcbiAgICAgICAgICAgICAgICA/IFVpbnQzMkFycmF5XG4gICAgICAgICAgICAgICAgOiBtYXggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICAgPyBaZXJvQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHN1cGVyKHNpemUpO1xuICAgICAgICB0aGlzLmZpbGwoMCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2sge1xuICAgIGhlYXA7XG4gICAgbGVuZ3RoO1xuICAgIC8vIHByaXZhdGUgY29uc3RydWN0b3JcbiAgICBzdGF0aWMgI2NvbnN0cnVjdGluZyA9IGZhbHNlO1xuICAgIHN0YXRpYyBjcmVhdGUobWF4KSB7XG4gICAgICAgIGNvbnN0IEhlYXBDbHMgPSBnZXRVaW50QXJyYXkobWF4KTtcbiAgICAgICAgaWYgKCFIZWFwQ2xzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTdGFjayhtYXgsIEhlYXBDbHMpO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtYXgsIEhlYXBDbHMpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghU3RhY2suI2NvbnN0cnVjdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zdGFudGlhdGUgU3RhY2sgdXNpbmcgU3RhY2suY3JlYXRlKG4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5oZWFwID0gbmV3IEhlYXBDbHMobWF4KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBwdXNoKG4pIHtcbiAgICAgICAgdGhpcy5oZWFwW3RoaXMubGVuZ3RoKytdID0gbjtcbiAgICB9XG4gICAgcG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdO1xuICAgIH1cbn1cbi8qKlxuICogRGVmYXVsdCBleHBvcnQsIHRoZSB0aGluZyB5b3UncmUgdXNpbmcgdGhpcyBtb2R1bGUgdG8gZ2V0LlxuICpcbiAqIEFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9wdGlvbnMgb2JqZWN0ICh3aXRoIHRoZSBleGNlcHRpb24gb2ZcbiAqIHtAbGluayBPcHRpb25zQmFzZS5tYXh9IGFuZCB7QGxpbmsgT3B0aW9uc0Jhc2UubWF4U2l6ZX0pIGFyZSBhZGRlZCBhc1xuICogbm9ybWFsIHB1YmxpYyBtZW1iZXJzLiAoYG1heGAgYW5kIGBtYXhCYXNlYCBhcmUgcmVhZC1vbmx5IGdldHRlcnMuKVxuICogQ2hhbmdpbmcgYW55IG9mIHRoZXNlIHdpbGwgYWx0ZXIgdGhlIGRlZmF1bHRzIGZvciBzdWJzZXF1ZW50IG1ldGhvZCBjYWxscyxcbiAqIGJ1dCBpcyBvdGhlcndpc2Ugc2FmZS5cbiAqL1xuY2xhc3MgTFJVQ2FjaGUge1xuICAgIC8vIHByb3BlcnRpZXMgY29taW5nIGluIGZyb20gdGhlIG9wdGlvbnMgb2YgdGhlc2UsIG9ubHkgbWF4IGFuZCBtYXhTaXplXG4gICAgLy8gcmVhbGx5ICpuZWVkKiB0byBiZSBwcm90ZWN0ZWQuIFRoZSByZXN0IGNhbiBiZSBtb2RpZmllZCwgYXMgdGhleSBqdXN0XG4gICAgLy8gc2V0IGRlZmF1bHRzIGZvciB2YXJpb3VzIG1ldGhvZHMuXG4gICAgI21heDtcbiAgICAjbWF4U2l6ZTtcbiAgICAjZGlzcG9zZTtcbiAgICAjZGlzcG9zZUFmdGVyO1xuICAgICNmZXRjaE1ldGhvZDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsfVxuICAgICAqL1xuICAgIHR0bDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsUmVzb2x1dGlvbn1cbiAgICAgKi9cbiAgICB0dGxSZXNvbHV0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGxBdXRvcHVyZ2V9XG4gICAgICovXG4gICAgdHRsQXV0b3B1cmdlO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkdldH1cbiAgICAgKi9cbiAgICB1cGRhdGVBZ2VPbkdldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9XG4gICAgICovXG4gICAgdXBkYXRlQWdlT25IYXM7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9XG4gICAgICovXG4gICAgYWxsb3dTdGFsZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EaXNwb3NlT25TZXR9XG4gICAgICovXG4gICAgbm9EaXNwb3NlT25TZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vVXBkYXRlVFRMfVxuICAgICAqL1xuICAgIG5vVXBkYXRlVFRMO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhFbnRyeVNpemV9XG4gICAgICovXG4gICAgbWF4RW50cnlTaXplO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5zaXplQ2FsY3VsYXRpb259XG4gICAgICovXG4gICAgc2l6ZUNhbGN1bGF0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb259XG4gICAgICovXG4gICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0RlbGV0ZU9uU3RhbGVHZXR9XG4gICAgICovXG4gICAgbm9EZWxldGVPblN0YWxlR2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlT25GZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9ufVxuICAgICAqL1xuICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5pZ25vcmVGZXRjaEFib3J0fVxuICAgICAqL1xuICAgIGlnbm9yZUZldGNoQWJvcnQ7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgICNzaXplO1xuICAgICNjYWxjdWxhdGVkU2l6ZTtcbiAgICAja2V5TWFwO1xuICAgICNrZXlMaXN0O1xuICAgICN2YWxMaXN0O1xuICAgICNuZXh0O1xuICAgICNwcmV2O1xuICAgICNoZWFkO1xuICAgICN0YWlsO1xuICAgICNmcmVlO1xuICAgICNkaXNwb3NlZDtcbiAgICAjc2l6ZXM7XG4gICAgI3N0YXJ0cztcbiAgICAjdHRscztcbiAgICAjaGFzRGlzcG9zZTtcbiAgICAjaGFzRmV0Y2hNZXRob2Q7XG4gICAgI2hhc0Rpc3Bvc2VBZnRlcjtcbiAgICAvKipcbiAgICAgKiBEbyBub3QgY2FsbCB0aGlzIG1ldGhvZCB1bmxlc3MgeW91IG5lZWQgdG8gaW5zcGVjdCB0aGVcbiAgICAgKiBpbm5lciB3b3JraW5ncyBvZiB0aGUgY2FjaGUuICBJZiBhbnl0aGluZyByZXR1cm5lZCBieSB0aGlzXG4gICAgICogb2JqZWN0IGlzIG1vZGlmaWVkIGluIGFueSB3YXksIHN0cmFuZ2UgYnJlYWthZ2UgbWF5IG9jY3VyLlxuICAgICAqXG4gICAgICogVGhlc2UgZmllbGRzIGFyZSBwcml2YXRlIGZvciBhIHJlYXNvbiFcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyB1bnNhZmVFeHBvc2VJbnRlcm5hbHMoYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgICAgICAgc3RhcnRzOiBjLiNzdGFydHMsXG4gICAgICAgICAgICB0dGxzOiBjLiN0dGxzLFxuICAgICAgICAgICAgc2l6ZXM6IGMuI3NpemVzLFxuICAgICAgICAgICAga2V5TWFwOiBjLiNrZXlNYXAsXG4gICAgICAgICAgICBrZXlMaXN0OiBjLiNrZXlMaXN0LFxuICAgICAgICAgICAgdmFsTGlzdDogYy4jdmFsTGlzdCxcbiAgICAgICAgICAgIG5leHQ6IGMuI25leHQsXG4gICAgICAgICAgICBwcmV2OiBjLiNwcmV2LFxuICAgICAgICAgICAgZ2V0IGhlYWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI2hlYWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRhaWwoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuI3RhaWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJlZTogYy4jZnJlZSxcbiAgICAgICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgICAgIGlzQmFja2dyb3VuZEZldGNoOiAocCkgPT4gYy4jaXNCYWNrZ3JvdW5kRmV0Y2gocCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmV0Y2g6IChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkgPT4gYy4jYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSxcbiAgICAgICAgICAgIG1vdmVUb1RhaWw6IChpbmRleCkgPT4gYy4jbW92ZVRvVGFpbChpbmRleCksXG4gICAgICAgICAgICBpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jaW5kZXhlcyhvcHRpb25zKSxcbiAgICAgICAgICAgIHJpbmRleGVzOiAob3B0aW9ucykgPT4gYy4jcmluZGV4ZXMob3B0aW9ucyksXG4gICAgICAgICAgICBpc1N0YWxlOiAoaW5kZXgpID0+IGMuI2lzU3RhbGUoaW5kZXgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQcm90ZWN0ZWQgcmVhZC1vbmx5IG1lbWJlcnNcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UubWF4fSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXhTaXplfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBtYXhTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWF4U2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRvdGFsIGNvbXB1dGVkIHNpemUgb2YgaXRlbXMgaW4gdGhlIGNhY2hlIChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGNhbGN1bGF0ZWRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FsY3VsYXRlZFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgc3RvcmVkIGluIHRoZSBjYWNoZSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmZldGNoTWV0aG9kfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBmZXRjaE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZldGNoTWV0aG9kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuZGlzcG9zZX0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5kaXNwb3NlQWZ0ZXJ9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2VBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2VBZnRlcjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1heCA9IDAsIHR0bCwgdHRsUmVzb2x1dGlvbiA9IDEsIHR0bEF1dG9wdXJnZSwgdXBkYXRlQWdlT25HZXQsIHVwZGF0ZUFnZU9uSGFzLCBhbGxvd1N0YWxlLCBkaXNwb3NlLCBkaXNwb3NlQWZ0ZXIsIG5vRGlzcG9zZU9uU2V0LCBub1VwZGF0ZVRUTCwgbWF4U2l6ZSA9IDAsIG1heEVudHJ5U2l6ZSA9IDAsIHNpemVDYWxjdWxhdGlvbiwgZmV0Y2hNZXRob2QsIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiwgbm9EZWxldGVPblN0YWxlR2V0LCBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiwgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCwgaWdub3JlRmV0Y2hBYm9ydCwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChtYXggIT09IDAgJiYgIWlzUG9zSW50KG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBvcHRpb24gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBVaW50QXJyYXkgPSBtYXggPyBnZXRVaW50QXJyYXkobWF4KSA6IEFycmF5O1xuICAgICAgICBpZiAoIVVpbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCB2YWx1ZTogJyArIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWF4ID0gbWF4O1xuICAgICAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5tYXhFbnRyeVNpemUgPSBtYXhFbnRyeVNpemUgfHwgdGhpcy4jbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5zaXplQ2FsY3VsYXRpb24gPSBzaXplQ2FsY3VsYXRpb247XG4gICAgICAgIGlmICh0aGlzLnNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNtYXhTaXplICYmICF0aGlzLm1heEVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZUNhbGN1bGF0aW9uIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBzZXQgdG8gbm9uLWZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZldGNoTWV0aG9kICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBmZXRjaE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmV0Y2hNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZldGNoTWV0aG9kID0gZmV0Y2hNZXRob2Q7XG4gICAgICAgIHRoaXMuI2hhc0ZldGNoTWV0aG9kID0gISFmZXRjaE1ldGhvZDtcbiAgICAgICAgdGhpcy4ja2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNrZXlMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiN2YWxMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiNuZXh0ID0gbmV3IFVpbnRBcnJheShtYXgpO1xuICAgICAgICB0aGlzLiNwcmV2ID0gbmV3IFVpbnRBcnJheShtYXgpO1xuICAgICAgICB0aGlzLiNoZWFkID0gMDtcbiAgICAgICAgdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgIHRoaXMuI2ZyZWUgPSBTdGFjay5jcmVhdGUobWF4KTtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlID0gZGlzcG9zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2VBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyID0gZGlzcG9zZUFmdGVyO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2hhc0Rpc3Bvc2UgPSAhIXRoaXMuI2Rpc3Bvc2U7XG4gICAgICAgIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciA9ICEhdGhpcy4jZGlzcG9zZUFmdGVyO1xuICAgICAgICB0aGlzLm5vRGlzcG9zZU9uU2V0ID0gISFub0Rpc3Bvc2VPblNldDtcbiAgICAgICAgdGhpcy5ub1VwZGF0ZVRUTCA9ICEhbm9VcGRhdGVUVEw7XG4gICAgICAgIHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uID0gISFub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSAhIWFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSAhIWFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgICAgIHRoaXMuaWdub3JlRmV0Y2hBYm9ydCA9ICEhaWdub3JlRmV0Y2hBYm9ydDtcbiAgICAgICAgLy8gTkI6IG1heEVudHJ5U2l6ZSBpcyBzZXQgdG8gbWF4U2l6ZSBpZiBpdCdzIHNldFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgIT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXhTaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLiNtYXhTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhFbnRyeVNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4RW50cnlTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVNpemVUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZTtcbiAgICAgICAgdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQgPSAhIW5vRGVsZXRlT25TdGFsZUdldDtcbiAgICAgICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlQWdlT25IYXMgPSAhIXVwZGF0ZUFnZU9uSGFzO1xuICAgICAgICB0aGlzLnR0bFJlc29sdXRpb24gPVxuICAgICAgICAgICAgaXNQb3NJbnQodHRsUmVzb2x1dGlvbikgfHwgdHRsUmVzb2x1dGlvbiA9PT0gMFxuICAgICAgICAgICAgICAgID8gdHRsUmVzb2x1dGlvblxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZTtcbiAgICAgICAgdGhpcy50dGwgPSB0dGwgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIG5vdCBhbGxvdyBjb21wbGV0ZWx5IHVuYm91bmRlZCBjYWNoZXNcbiAgICAgICAgaWYgKHRoaXMuI21heCA9PT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiB0aGlzLiNtYXhTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHRsQXV0b3B1cmdlICYmICF0aGlzLiNtYXggJiYgIXRoaXMuI21heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAnTFJVX0NBQ0hFX1VOQk9VTkRFRCc7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgICAgICAgICAgICAgIHdhcm5lZC5hZGQoY29kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ1RUTCBjYWNoaW5nIHdpdGhvdXQgdHRsQXV0b3B1cmdlLCBtYXgsIG9yIG1heFNpemUgY2FuICcgK1xuICAgICAgICAgICAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJztcbiAgICAgICAgICAgICAgICBlbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSByZW1haW5pbmcgVFRMIHRpbWUgZm9yIGEgZ2l2ZW4gZW50cnkga2V5XG4gICAgICovXG4gICAgZ2V0UmVtYWluaW5nVFRMKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy4ja2V5TWFwLmhhcyhrZXkpID8gSW5maW5pdHkgOiAwO1xuICAgIH1cbiAgICAjaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCkge1xuICAgICAgICBjb25zdCB0dGxzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICBjb25zdCBzdGFydHMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIHRoaXMuI3R0bHMgPSB0dGxzO1xuICAgICAgICB0aGlzLiNzdGFydHMgPSBzdGFydHM7XG4gICAgICAgIHRoaXMuI3NldEl0ZW1UVEwgPSAoaW5kZXgsIHR0bCwgc3RhcnQgPSBwZXJmLm5vdygpKSA9PiB7XG4gICAgICAgICAgICBzdGFydHNbaW5kZXhdID0gdHRsICE9PSAwID8gc3RhcnQgOiAwO1xuICAgICAgICAgICAgdHRsc1tpbmRleF0gPSB0dGw7XG4gICAgICAgICAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsQXV0b3B1cmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKHRoaXMuI2tleUxpc3RbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHR0bCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIHVucmVmKCkgbm90IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdC51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgc3RhcnRzW2luZGV4XSA9IHR0bHNbaW5kZXhdICE9PSAwID8gcGVyZi5ub3coKSA6IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3N0YXR1c1RUTCA9IChzdGF0dXMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHRsc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0dGwgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgc3RhdHVzLnR0bCA9IHR0bDtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBzdGF0dXMubm93ID0gY2FjaGVkTm93IHx8IGdldE5vdygpO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5yZW1haW5pbmdUVEwgPSBzdGF0dXMubm93ICsgdHRsIC0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlYm91bmNlIGNhbGxzIHRvIHBlcmYubm93KCkgdG8gMXMgc28gd2UncmUgbm90IGhpdHRpbmdcbiAgICAgICAgLy8gdGhhdCBjb3N0bHkgY2FsbCByZXBlYXRlZGx5LlxuICAgICAgICBsZXQgY2FjaGVkTm93ID0gMDtcbiAgICAgICAgY29uc3QgZ2V0Tm93ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHBlcmYubm93KCk7XG4gICAgICAgICAgICBpZiAodGhpcy50dGxSZXNvbHV0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE5vdyA9IG47XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHNldFRpbWVvdXQoKCkgPT4gKGNhY2hlZE5vdyA9IDApLCB0aGlzLnR0bFJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHQudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldFJlbWFpbmluZ1RUTCA9IGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHRsc1tpbmRleF0gPT09IDAgfHwgc3RhcnRzW2luZGV4XSA9PT0gMFxuICAgICAgICAgICAgICAgID8gSW5maW5pdHlcbiAgICAgICAgICAgICAgICA6IHN0YXJ0c1tpbmRleF0gKyB0dGxzW2luZGV4XSAtIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNpc1N0YWxlID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0dGxzW2luZGV4XSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0c1tpbmRleF0gIT09IDAgJiZcbiAgICAgICAgICAgICAgICAoY2FjaGVkTm93IHx8IGdldE5vdygpKSAtIHN0YXJ0c1tpbmRleF0gPiB0dGxzW2luZGV4XSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGNvbmRpdGlvbmFsbHkgc2V0IHByaXZhdGUgbWV0aG9kcyByZWxhdGVkIHRvIFRUTFxuICAgICN1cGRhdGVJdGVtQWdlID0gKCkgPT4geyB9O1xuICAgICNzdGF0dXNUVEwgPSAoKSA9PiB7IH07XG4gICAgI3NldEl0ZW1UVEwgPSAoKSA9PiB7IH07XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAjaXNTdGFsZSA9ICgpID0+IGZhbHNlO1xuICAgICNpbml0aWFsaXplU2l6ZVRyYWNraW5nKCkge1xuICAgICAgICBjb25zdCBzaXplcyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICB0aGlzLiNzaXplcyA9IHNpemVzO1xuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZSA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplIC09IHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgIHNpemVzW2luZGV4XSA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3JlcXVpcmVTaXplID0gKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gcHJvdmlzaW9uYWxseSBhY2NlcHQgYmFja2dyb3VuZCBmZXRjaGVzLlxuICAgICAgICAgICAgLy8gYWN0dWFsIHZhbHVlIHNpemUgd2lsbCBiZSBjaGVja2VkIHdoZW4gdGhleSByZXR1cm4uXG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHNpemVDYWxjdWxhdGlvbih2LCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHJldHVybiBpbnZhbGlkIChleHBlY3QgcG9zaXRpdmUgaW50ZWdlciknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzaXplIHZhbHVlIChtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaGVuIG1heFNpemUgb3IgbWF4RW50cnlTaXplIGlzIHVzZWQsIHNpemVDYWxjdWxhdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvciBzaXplIG11c3QgYmUgc2V0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZSA9IChpbmRleCwgc2l6ZSwgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBzaXplc1tpbmRleF0gPSBzaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMuI21heFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gdGhpcy4jbWF4U2l6ZSAtIHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy4jY2FsY3VsYXRlZFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2aWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplICs9IHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZW50cnlTaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBzdGF0dXMudG90YWxDYWxjdWxhdGVkU2l6ZSA9IHRoaXMuI2NhbGN1bGF0ZWRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAjcmVtb3ZlSXRlbVNpemUgPSBfaSA9PiB7IH07XG4gICAgI2FkZEl0ZW1TaXplID0gKF9pLCBfcywgX3N0KSA9PiB7IH07XG4gICAgI3JlcXVpcmVTaXplID0gKF9rLCBfdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChzaXplIHx8IHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBvbiBjYWNoZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgKiNpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiN0YWlsOyB0cnVlOykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4jaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiNwcmV2W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqI3JpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNoZWFkOyB0cnVlOykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4jaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiNuZXh0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAjaXNWYWxpZEluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy4ja2V5TWFwLmdldCh0aGlzLiNrZXlMaXN0W2luZGV4XSkgPT09IGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIGBba2V5LCB2YWx1ZV1gIHBhaXJzLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBbdGhpcy4ja2V5TGlzdFtpXSwgdGhpcy4jdmFsTGlzdFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS5lbnRyaWVzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIGBba2V5LCB2YWx1ZV1gIHBhaXJzLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJlbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFt0aGlzLiNrZXlMaXN0W2ldLCB0aGlzLiN2YWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGtleXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKmtleXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS5rZXlzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBrZXlzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpya2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSB2YWx1ZXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnZhbHVlcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLnZhbHVlc31cbiAgICAgKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUgdmFsdWVzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpydmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRpbmcgb3ZlciB0aGUgY2FjaGUgaXRzZWxmIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRzIGFzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLmVudHJpZXN9XG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCBhIHZhbHVlIGZvciB3aGljaCB0aGUgc3VwcGxpZWQgZm4gbWV0aG9kIHJldHVybnMgYSB0cnV0aHkgdmFsdWUsXG4gICAgICogc2ltaWxhciB0byBBcnJheS5maW5kKCkuICBmbiBpcyBjYWxsZWQgYXMgZm4odmFsdWUsIGtleSwgY2FjaGUpLlxuICAgICAqL1xuICAgIGZpbmQoZm4sIGdldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmbih2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy4ja2V5TGlzdFtpXSwgZ2V0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtIGluIHRoZSBjYWNoZSwgaW4gb3JkZXIgZnJvbVxuICAgICAqIG1vc3QgcmVjZW50bHkgdXNlZCB0byBsZWFzdCByZWNlbnRseSB1c2VkLiAgZm4gaXMgY2FsbGVkIGFzXG4gICAgICogZm4odmFsdWUsIGtleSwgY2FjaGUpLiAgRG9lcyBub3QgdXBkYXRlIGFnZSBvciByZWNlbnR5IG9mIHVzZS5cbiAgICAgKiBEb2VzIG5vdCBpdGVyYXRlIG92ZXIgc3RhbGUgdmFsdWVzLlxuICAgICAqL1xuICAgIGZvckVhY2goZm4sIHRoaXNwID0gdGhpcykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc3AsIHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyB7QGxpbmsgTFJVQ2FjaGUuZm9yRWFjaH0gYnV0IGl0ZW1zIGFyZSBpdGVyYXRlZCBvdmVyIGluXG4gICAgICogcmV2ZXJzZSBvcmRlci4gIChpZSwgbGVzcyByZWNlbnRseSB1c2VkIGl0ZW1zIGFyZSBpdGVyYXRlZCBvdmVyIGZpcnN0LilcbiAgICAgKi9cbiAgICByZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpc3AsIHZhbHVlLCB0aGlzLiNrZXlMaXN0W2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW55IHN0YWxlIGVudHJpZXMuIFJldHVybnMgdHJ1ZSBpZiBhbnl0aGluZyB3YXMgcmVtb3ZlZCxcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcHVyZ2VTdGFsZSgpIHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZSh0aGlzLiNrZXlMaXN0W2ldKTtcbiAgICAgICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIFtrZXksIHtAbGluayBMUlVDYWNoZS5FbnRyeX1dIHR1cGxlcyB3aGljaCBjYW4gYmVcbiAgICAgKiBwYXNzZWQgdG8gY2FjaGUubG9hZCgpXG4gICAgICovXG4gICAgZHVtcCgpIHtcbiAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy4ja2V5TGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB7IHZhbHVlIH07XG4gICAgICAgICAgICBpZiAodGhpcy4jdHRscyAmJiB0aGlzLiNzdGFydHMpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS50dGwgPSB0aGlzLiN0dGxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBkdW1wIHRoZSBzdGFydCByZWxhdGl2ZSB0byBhIHBvcnRhYmxlIHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IHBlcmYubm93KCkgLSB0aGlzLiNzdGFydHNbaV07XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLSBhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI3NpemVzKSB7XG4gICAgICAgICAgICAgICAgZW50cnkuc2l6ZSA9IHRoaXMuI3NpemVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyLnVuc2hpZnQoW2tleSwgZW50cnldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY2FjaGUgYW5kIGxvYWQgaW4gdGhlIGl0ZW1zIGluIGVudHJpZXMgaW4gdGhlIG9yZGVyIGxpc3RlZC5cbiAgICAgKiBOb3RlIHRoYXQgdGhlIHNoYXBlIG9mIHRoZSByZXN1bHRpbmcgY2FjaGUgbWF5IGJlIGRpZmZlcmVudCBpZiB0aGVcbiAgICAgKiBzYW1lIG9wdGlvbnMgYXJlIG5vdCB1c2VkIGluIGJvdGggY2FjaGVzLlxuICAgICAqL1xuICAgIGxvYWQoYXJyKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnRyeS5zdGFydCBpcyBhIHBvcnRhYmxlIHRpbWVzdGFtcCwgYnV0IHdlIG1heSBiZSB1c2luZ1xuICAgICAgICAgICAgICAgIC8vIG5vZGUncyBwZXJmb3JtYW5jZS5ub3coKSwgc28gY2FsY3VsYXRlIHRoZSBvZmZzZXQsIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgdGhlIGludGVuZGVkIHJlbWFpbmluZyBUVEwsIG5vIG1hdHRlciBob3cgbG9uZyBpdCdzXG4gICAgICAgICAgICAgICAgLy8gYmVlbiBvbiBpY2UuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBpdCdzIG9rIGZvciB0aGlzIHRvIGJlIGEgYml0IHNsb3csIGl0J3MgYSByYXJlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBEYXRlLm5vdygpIC0gZW50cnkuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBwZXJmLm5vdygpIC0gYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBlbnRyeS52YWx1ZSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHZhbHVlIHRvIHRoZSBjYWNoZS5cbiAgICAgKi9cbiAgICBzZXQoaywgdiwgc2V0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdHRsID0gdGhpcy50dGwsIHN0YXJ0LCBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLCBzdGF0dXMsIH0gPSBzZXRPcHRpb25zO1xuICAgICAgICBsZXQgeyBub1VwZGF0ZVRUTCA9IHRoaXMubm9VcGRhdGVUVEwgfSA9IHNldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLiNyZXF1aXJlU2l6ZShrLCB2LCBzZXRPcHRpb25zLnNpemUgfHwgMCwgc2l6ZUNhbGN1bGF0aW9uKTtcbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gZG9lc24ndCBmaXQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIC8vIE5COiBtYXhFbnRyeVNpemUgc2V0IHRvIG1heFNpemUgYnkgZGVmYXVsdFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgJiYgc2l6ZSA+IHRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICdtaXNzJztcbiAgICAgICAgICAgICAgICBzdGF0dXMubWF4RW50cnlTaXplRXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGF2ZSB0byBkZWxldGUsIGluIGNhc2Ugc29tZXRoaW5nIGlzIHRoZXJlIGFscmVhZHkuXG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuI3NpemUgPT09IDAgPyB1bmRlZmluZWQgOiB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25cbiAgICAgICAgICAgIGluZGV4ID0gKHRoaXMuI3NpemUgPT09IDBcbiAgICAgICAgICAgICAgICA/IHRoaXMuI3RhaWxcbiAgICAgICAgICAgICAgICA6IHRoaXMuI2ZyZWUubGVuZ3RoICE9PSAwXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy4jZnJlZS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI3NpemUgPT09IHRoaXMuI21heFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiNldmljdChmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy4jc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2luZGV4XSA9IGs7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IHY7XG4gICAgICAgICAgICB0aGlzLiNrZXlNYXAuc2V0KGssIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuI25leHRbdGhpcy4jdGFpbF0gPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuI3ByZXZbaW5kZXhdID0gdGhpcy4jdGFpbDtcbiAgICAgICAgICAgIHRoaXMuI3RhaWwgPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuI3NpemUrKztcbiAgICAgICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplKGluZGV4LCBzaXplLCBzdGF0dXMpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ2FkZCc7XG4gICAgICAgICAgICBub1VwZGF0ZVRUTCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlXG4gICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbCA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHYgIT09IG9sZFZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNGZXRjaE1ldGhvZCAmJiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaChvbGRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbC5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ3JlcGxhY2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/LihvbGRWYWwsIGssICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbb2xkVmFsLCBrLCAnc2V0J10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ3JlcGxhY2UnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9sZFZhbCAmJiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaChvbGRWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9sZFZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBvbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICd1cGRhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0dGwgIT09IDAgJiYgIXRoaXMuI3R0bHMpIHtcbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiN0dGxzKSB7XG4gICAgICAgICAgICBpZiAoIW5vVXBkYXRlVFRMKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc2V0SXRlbVRUTChpbmRleCwgdHRsLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vRGlzcG9zZU9uU2V0ICYmIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2aWN0IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGl0ZW0sIHJldHVybmluZyBpdHMgdmFsdWUgb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBpZiBjYWNoZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuI3ZhbExpc3RbdGhpcy4jaGVhZF07XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2V2aWN0KGZyZWUpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IHRoaXMuI2hlYWQ7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2hlYWRdO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtoZWFkXTtcbiAgICAgICAgaWYgKHRoaXMuI2hhc0ZldGNoTWV0aG9kICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZXZpY3RlZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLiNoYXNEaXNwb3NlIHx8IHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgJ2V2aWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssICdldmljdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShoZWFkKTtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IGFib3V0IHRvIHVzZSB0aGUgaW5kZXgsIHRoZW4gbnVsbCB0aGVzZSBvdXRcbiAgICAgICAgaWYgKGZyZWUpIHtcbiAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2hlYWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtoZWFkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgIHJldHVybiBoZWFkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIGtleSBpcyBpbiB0aGUgY2FjaGUsIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHJlY2VuY3kgb2YgdXNlLlxuICAgICAqIFdpbGwgcmV0dXJuIGZhbHNlIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCBldmVuIHRob3VnaCBpdCBpcyB0ZWNobmljYWxseVxuICAgICAqIGluIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIFdpbGwgbm90IHVwZGF0ZSBpdGVtIGFnZSB1bmxlc3NcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25IYXN9IGlzIHNldC5cbiAgICAgKi9cbiAgICBoYXMoaywgaGFzT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdXBkYXRlQWdlT25IYXMgPSB0aGlzLnVwZGF0ZUFnZU9uSGFzLCBzdGF0dXMgfSA9IGhhc09wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSAmJlxuICAgICAgICAgICAgICAgIHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy4jaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlQWdlT25IYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdoaXQnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdzdGFsZSc7XG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgc3RhdHVzLmhhcyA9ICdtaXNzJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpa2Uge0BsaW5rIExSVUNhY2hlI2dldH0gYnV0IGRvZXNuJ3QgdXBkYXRlIHJlY2VuY3kgb3IgZGVsZXRlIHN0YWxlXG4gICAgICogaXRlbXMuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCB1bmxlc3NcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZX0gaXMgc2V0LlxuICAgICAqL1xuICAgIHBlZWsoaywgcGVla09wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHBlZWtPcHRpb25zO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpbmRleCkpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICAvLyBlaXRoZXIgc3RhbGUgYW5kIGFsbG93ZWQsIG9yIGZvcmNpbmcgYSByZWZyZXNoIG9mIG5vbi1zdGFsZSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICBjb25zdCB2ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCB7IHNpZ25hbCB9ID0gb3B0aW9ucztcbiAgICAgICAgLy8gd2hlbi9pZiBvdXIgQUMgc2lnbmFscywgdGhlbiBzdG9wIGxpc3RlbmluZyB0byB0aGVpcnMuXG4gICAgICAgIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBhYy5hYm9ydChzaWduYWwucmVhc29uKSwge1xuICAgICAgICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSB7XG4gICAgICAgICAgICBzaWduYWw6IGFjLnNpZ25hbCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYiA9ICh2LCB1cGRhdGVDYWNoZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZUFib3J0ID0gb3B0aW9ucy5pZ25vcmVGZXRjaEFib3J0ICYmIHYgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydGVkICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gYWMuc2lnbmFsLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUFib3J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydElnbm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFib3J0ZWQgJiYgIWlnbm9yZUFib3J0ICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaEZhaWwoYWMuc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlaXRoZXIgd2UgZGlkbid0IGFib3J0LCBhbmQgYXJlIHN0aWxsIGhlcmUsIG9yIHdlIGRpZCwgYW5kIGlnbm9yZWRcbiAgICAgICAgICAgIGNvbnN0IGJmID0gcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2luZGV4XSA9PT0gcCkge1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0KGssIHYsIGZldGNoT3B0cy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZWIgPSAoZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRXJyb3IgPSBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaEZhaWwoZXIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmZXRjaEZhaWwgPSAoZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWJvcnRlZCB9ID0gYWMuc2lnbmFsO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dTdGFsZUFib3J0ZWQgPSBhYm9ydGVkICYmIG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U3RhbGUgPSBhbGxvd1N0YWxlQWJvcnRlZCB8fCBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICAgICAgY29uc3Qgbm9EZWxldGUgPSBhbGxvd1N0YWxlIHx8IG9wdGlvbnMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgYmYgPSBwO1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxsb3cgc3RhbGUgb24gZmV0Y2ggcmVqZWN0aW9ucywgdGhlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0YWxlIHZhbHVlIGlzIG5vdCByZW1vdmVkIGZyb20gdGhlIGNhY2hlIHdoZW4gdGhlIGZldGNoIGZhaWxzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbCA9ICFub0RlbGV0ZSB8fCBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZyA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChkZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbGxvd1N0YWxlQWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCByZXBsYWNlIHRoZSAqcHJvbWlzZSogd2l0aCB0aGUgc3RhbGUgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBkb25lIHdpdGggdGhlIHByb21pc2UgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgLy8gbGVhdmUgaXQgdW50b3VjaGVkIGlmIHdlJ3JlIHN0aWxsIHdhaXRpbmcgZm9yIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFib3J0ZWQgYmFja2dyb3VuZCBmZXRjaCB0aGF0IGhhc24ndCB5ZXQgcmV0dXJuZWQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93U3RhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMgJiYgYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmYuX19yZXR1cm5lZCA9PT0gYmYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGNhbGwgPSAocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZtcCA9IHRoaXMuI2ZldGNoTWV0aG9kPy4oaywgdiwgZmV0Y2hPcHRzKTtcbiAgICAgICAgICAgIGlmIChmbXAgJiYgZm1wIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGZtcC50aGVuKHYgPT4gcmVzKHYpLCByZWopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWdub3JlZCwgd2UgZ28gdW50aWwgd2UgZmluaXNoLCByZWdhcmRsZXNzLlxuICAgICAgICAgICAgLy8gZGVmZXIgY2hlY2sgdW50aWwgd2UgYXJlIGFjdHVhbGx5IGFib3J0aW5nLFxuICAgICAgICAgICAgLy8gc28gZmV0Y2hNZXRob2QgY2FuIG92ZXJyaWRlLlxuICAgICAgICAgICAgYWMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVGZXRjaEFib3J0IHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBpdCBldmVudHVhbGx5IHJlc29sdmVzLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB2ID0+IGNiKHYsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXR1cylcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRGlzcGF0Y2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZShwY2FsbCkudGhlbihjYiwgZWIpO1xuICAgICAgICBjb25zdCBiZiA9IE9iamVjdC5hc3NpZ24ocCwge1xuICAgICAgICAgICAgX19hYm9ydENvbnRyb2xsZXI6IGFjLFxuICAgICAgICAgICAgX19zdGFsZVdoaWxlRmV0Y2hpbmc6IHYsXG4gICAgICAgICAgICBfX3JldHVybmVkOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gaW50ZXJuYWwsIGRvbid0IGV4cG9zZSBzdGF0dXMuXG4gICAgICAgICAgICB0aGlzLnNldChrLCBiZiwgeyAuLi5mZXRjaE9wdHMub3B0aW9ucywgc3RhdHVzOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgI2lzQmFja2dyb3VuZEZldGNoKHApIHtcbiAgICAgICAgaWYgKCF0aGlzLiNoYXNGZXRjaE1ldGhvZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgYiA9IHA7XG4gICAgICAgIHJldHVybiAoISFiICYmXG4gICAgICAgICAgICBiIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgYi5oYXNPd25Qcm9wZXJ0eSgnX19zdGFsZVdoaWxlRmV0Y2hpbmcnKSAmJlxuICAgICAgICAgICAgYi5fX2Fib3J0Q29udHJvbGxlciBpbnN0YW5jZW9mIEFib3J0Q29udHJvbGxlcik7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKGssIGZldGNoT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgIC8vIGdldCBvcHRpb25zXG4gICAgICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCwgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsIFxuICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICB0dGwgPSB0aGlzLnR0bCwgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LCBzaXplID0gMCwgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCwgXG4gICAgICAgIC8vIGZldGNoIGV4Y2x1c2l2ZSBvcHRpb25zXG4gICAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLCBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sIGlnbm9yZUZldGNoQWJvcnQgPSB0aGlzLmlnbm9yZUZldGNoQWJvcnQsIGFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsIGNvbnRleHQsIGZvcmNlUmVmcmVzaCA9IGZhbHNlLCBzdGF0dXMsIHNpZ25hbCwgfSA9IGZldGNoT3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLiNoYXNGZXRjaE1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnZ2V0JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dTdGFsZSxcbiAgICAgICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsbG93U3RhbGUsXG4gICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgIG5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHNpemVDYWxjdWxhdGlvbixcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgICAgICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgICAgICAgICBhbGxvd1N0YWxlT25GZXRjaEFib3J0LFxuICAgICAgICAgICAgaWdub3JlRmV0Y2hBYm9ydCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ21pc3MnO1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gKHAuX19yZXR1cm5lZCA9IHApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FjaGUsIG1heWJlIGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWxlID0gYWxsb3dTdGFsZSAmJiB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaW5mbGlnaHQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFsZSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAodi5fX3JldHVybmVkID0gdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBmb3JjZSBhIHJlZnJlc2gsIHRoYXQgbWVhbnMgZG8gTk9UIHNlcnZlIHRoZSBjYWNoZWQgdmFsdWUsXG4gICAgICAgICAgICAvLyB1bmxlc3Mgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2YgcmVmcmVzaGluZyB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjb25zdCBpc1N0YWxlID0gdGhpcy4jaXNTdGFsZShpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiAhaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlIG9yIGEgZm9yY2VkIHJlZnJlc2gsIGFuZCBub3QgYWxyZWFkeSBmZXRjaGluZy5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTdGFsZSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YWxlVmFsID0gaGFzU3RhbGUgJiYgYWxsb3dTdGFsZTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSBpc1N0YWxlID8gJ3N0YWxlJyA6ICdyZWZyZXNoJztcbiAgICAgICAgICAgICAgICBpZiAoc3RhbGVWYWwgJiYgaXNTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWxlVmFsID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IChwLl9fcmV0dXJuZWQgPSBwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS4gV2lsbCB1cGRhdGUgdGhlIHJlY2VuY3kgb2YgdGhlIGNhY2hlXG4gICAgICogZW50cnkgZm91bmQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUga2V5IGlzIG5vdCBmb3VuZCwgZ2V0KCkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZ2V0KGssIGdldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCwgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsIHN0YXR1cywgfSA9IGdldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBmZXRjaGluZyA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdzdGFsZSc7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9ubHkgaWYgbm90IGFuIGluLWZsaWdodCBiYWNrZ3JvdW5kIGZldGNoXG4gICAgICAgICAgICAgICAgaWYgKCFmZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vRGVsZXRlT25TdGFsZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBhbGxvd1N0YWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTdGFsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBmZXRjaGluZyBpdCwgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBpdCB5ZXRcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBzdGFsZSwgd2hpY2ggbWVhbnMgdGhpcyBpc24ndCBhIHN0YWxlV2hpbGVSZWZldGNoaW5nLlxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IHN0YWxlLCBhbmQgZmV0Y2hpbmcsIEFORCBoYXMgYSBfX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlLCB0aGVuIHRoYXQgbWVhbnMgdGhlIHVzZXIgZmV0Y2hlZCB3aXRoIHtmb3JjZVJlZnJlc2g6dHJ1ZX0sXG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBzYWZlIHRvIHJldHVybiB0aGF0IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChmZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdtaXNzJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAjY29ubmVjdChwLCBuKSB7XG4gICAgICAgIHRoaXMuI3ByZXZbbl0gPSBwO1xuICAgICAgICB0aGlzLiNuZXh0W3BdID0gbjtcbiAgICB9XG4gICAgI21vdmVUb1RhaWwoaW5kZXgpIHtcbiAgICAgICAgLy8gaWYgdGFpbCBhbHJlYWR5LCBub3RoaW5nIHRvIGRvXG4gICAgICAgIC8vIGlmIGhlYWQsIG1vdmUgaGVhZCB0byBuZXh0W2luZGV4XVxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vICAgbW92ZSBuZXh0W3ByZXZbaW5kZXhdXSB0byBuZXh0W2luZGV4XSAoaGVhZCBoYXMgbm8gcHJldilcbiAgICAgICAgLy8gICBtb3ZlIHByZXZbbmV4dFtpbmRleF1dIHRvIHByZXZbaW5kZXhdXG4gICAgICAgIC8vIHByZXZbaW5kZXhdID0gdGFpbFxuICAgICAgICAvLyBuZXh0W3RhaWxdID0gaW5kZXhcbiAgICAgICAgLy8gdGFpbCA9IGluZGV4XG4gICAgICAgIGlmIChpbmRleCAhPT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiNwcmV2W2luZGV4XSwgdGhpcy4jbmV4dFtpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiN0YWlsLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLiN0YWlsID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGtleSBvdXQgb2YgdGhlIGNhY2hlLlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IHdhcyBkZWxldGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZGVsZXRlKGspIHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3NpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2RlbGV0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4jaGFzRGlzcG9zZSB8fCB0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHYsIGssICdkZWxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgJ2RlbGV0ZSddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdGFpbCA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXh0W3RoaXMuI3ByZXZbaW5kZXhdXSA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jcHJldlt0aGlzLiNuZXh0W2luZGV4XV0gPSB0aGlzLiNwcmV2W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzaXplLS07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2ZyZWUucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQ/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZSBlbnRpcmVseSwgdGhyb3dpbmcgYXdheSBhbGwgdmFsdWVzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRoaXMuI3JpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2RlbGV0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gdGhpcy4ja2V5TGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHYsIGssICdkZWxldGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgJ2RlbGV0ZSddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4ja2V5TWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuI3ZhbExpc3QuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiNrZXlMaXN0LmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICB0aGlzLiN0dGxzLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLiNzdGFydHMuZmlsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuI3NpemVzLmZpbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaGVhZCA9IDA7XG4gICAgICAgIHRoaXMuI3RhaWwgPSAwO1xuICAgICAgICB0aGlzLiNmcmVlLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuZXhwb3J0cy5kZWZhdWx0ID0gTFJVQ2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMUlVDYWNoZSIsInBlcmYiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJ3YXJuZWQiLCJTZXQiLCJlbWl0V2FybmluZyIsIm1zZyIsInR5cGUiLCJjb2RlIiwiZm4iLCJwcm9jZXNzIiwiY29uc29sZSIsImVycm9yIiwic2hvdWxkV2FybiIsImhhcyIsIlRZUEUiLCJTeW1ib2wiLCJpc1Bvc0ludCIsIm4iLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsImdldFVpbnRBcnJheSIsIm1heCIsInBvdyIsIlVpbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIlplcm9BcnJheSIsIkFycmF5IiwiY29uc3RydWN0b3IiLCJzaXplIiwiZmlsbCIsIlN0YWNrIiwiY29uc3RydWN0aW5nIiwiY3JlYXRlIiwiSGVhcENscyIsInMiLCJUeXBlRXJyb3IiLCJoZWFwIiwibGVuZ3RoIiwicHVzaCIsInBvcCIsIm1heFNpemUiLCJkaXNwb3NlIiwiZGlzcG9zZUFmdGVyIiwiZmV0Y2hNZXRob2QiLCJjYWxjdWxhdGVkU2l6ZSIsImtleU1hcCIsImtleUxpc3QiLCJ2YWxMaXN0IiwibmV4dCIsInByZXYiLCJoZWFkIiwidGFpbCIsImZyZWUiLCJkaXNwb3NlZCIsInNpemVzIiwic3RhcnRzIiwidHRscyIsImhhc0Rpc3Bvc2UiLCJoYXNGZXRjaE1ldGhvZCIsImhhc0Rpc3Bvc2VBZnRlciIsInVuc2FmZUV4cG9zZUludGVybmFscyIsImMiLCJpc0JhY2tncm91bmRGZXRjaCIsInAiLCJiYWNrZ3JvdW5kRmV0Y2giLCJrIiwiaW5kZXgiLCJvcHRpb25zIiwiY29udGV4dCIsIm1vdmVUb1RhaWwiLCJpbmRleGVzIiwicmluZGV4ZXMiLCJpc1N0YWxlIiwidXBkYXRlSXRlbUFnZSIsInN0YXR1c1RUTCIsInNldEl0ZW1UVEwiLCJyZW1vdmVJdGVtU2l6ZSIsIl9pIiwiYWRkSXRlbVNpemUiLCJfcyIsIl9zdCIsInJlcXVpcmVTaXplIiwiX2siLCJfdiIsInNpemVDYWxjdWxhdGlvbiIsInR0bCIsInR0bFJlc29sdXRpb24iLCJ0dGxBdXRvcHVyZ2UiLCJ1cGRhdGVBZ2VPbkdldCIsInVwZGF0ZUFnZU9uSGFzIiwiYWxsb3dTdGFsZSIsIm5vRGlzcG9zZU9uU2V0Iiwibm9VcGRhdGVUVEwiLCJtYXhFbnRyeVNpemUiLCJub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24iLCJub0RlbGV0ZU9uU3RhbGVHZXQiLCJhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiIsImFsbG93U3RhbGVPbkZldGNoQWJvcnQiLCJpZ25vcmVGZXRjaEFib3J0IiwiVWludEFycmF5IiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJNYXAiLCJpbml0aWFsaXplU2l6ZVRyYWNraW5nIiwiaW5pdGlhbGl6ZVRUTFRyYWNraW5nIiwiYWRkIiwiZ2V0UmVtYWluaW5nVFRMIiwia2V5IiwiSW5maW5pdHkiLCJzdGFydCIsInQiLCJzZXRUaW1lb3V0IiwiZGVsZXRlIiwidW5yZWYiLCJzdGF0dXMiLCJjYWNoZWROb3ciLCJnZXROb3ciLCJyZW1haW5pbmdUVEwiLCJnZXQiLCJ2IiwiZXZpY3QiLCJlbnRyeVNpemUiLCJ0b3RhbENhbGN1bGF0ZWRTaXplIiwiaSIsImlzVmFsaWRJbmRleCIsImVudHJpZXMiLCJyZW50cmllcyIsImtleXMiLCJya2V5cyIsInZhbHVlcyIsInJ2YWx1ZXMiLCJpdGVyYXRvciIsImZpbmQiLCJnZXRPcHRpb25zIiwiX19zdGFsZVdoaWxlRmV0Y2hpbmciLCJmb3JFYWNoIiwidGhpc3AiLCJjYWxsIiwicmZvckVhY2giLCJwdXJnZVN0YWxlIiwiZGVsZXRlZCIsImR1bXAiLCJhcnIiLCJlbnRyeSIsImFnZSIsInVuc2hpZnQiLCJsb2FkIiwiY2xlYXIiLCJzZXQiLCJzZXRPcHRpb25zIiwibWF4RW50cnlTaXplRXhjZWVkZWQiLCJvbGRWYWwiLCJfX2Fib3J0Q29udHJvbGxlciIsImFib3J0Iiwib2xkVmFsdWUiLCJkdCIsInRhc2siLCJzaGlmdCIsInZhbCIsImhhc09wdGlvbnMiLCJwZWVrIiwicGVla09wdGlvbnMiLCJhYyIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWFzb24iLCJmZXRjaE9wdHMiLCJjYiIsInVwZGF0ZUNhY2hlIiwiYWJvcnRlZCIsImlnbm9yZUFib3J0IiwiZmV0Y2hBYm9ydGVkIiwiZmV0Y2hFcnJvciIsImZldGNoQWJvcnRJZ25vcmVkIiwiZmV0Y2hSZXNvbHZlZCIsImZldGNoRmFpbCIsImJmIiwiZmV0Y2hVcGRhdGVkIiwiZWIiLCJlciIsImZldGNoUmVqZWN0ZWQiLCJhbGxvd1N0YWxlQWJvcnRlZCIsIm5vRGVsZXRlIiwiZGVsIiwicmV0dXJuZWRTdGFsZSIsIl9fcmV0dXJuZWQiLCJwY2FsbCIsInJlcyIsInJlaiIsImZtcCIsIlByb21pc2UiLCJ0aGVuIiwiZmV0Y2hEaXNwYXRjaGVkIiwiYXNzaWduIiwiYiIsImhhc093blByb3BlcnR5IiwiZmV0Y2giLCJmZXRjaE9wdGlvbnMiLCJmb3JjZVJlZnJlc2giLCJzdGFsZSIsImhhc1N0YWxlIiwic3RhbGVWYWwiLCJmZXRjaGluZyIsImNvbm5lY3QiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/lru-cache/dist/cjs/index.js\n");

/***/ })

};
;